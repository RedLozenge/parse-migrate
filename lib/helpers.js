/* global exports */
'use strict';

/**
 * This module contains helper functions for migration scripts. The bulk of
 * its functionality hinges on "object templates." These are JS objects that
 * can be used to model Parse objects that you might want to either search for
 * or create.
 *
 * A template object looks like this:
 * 
 * {
 *     __class: 'ParseClassName',
 *     property1: 'Some Parse property',
 *     property2: false,
 *     property3: 42,
 *     property4: ['abc', '123'],
 *     property5: {
 *         __type: 'ParseFile',
 *         filename: 'somefile.png' },
 *     property6: {
 *         __search: 'OtherParseClassName',
 *         someProperty: 'find objects matching this string' },
 *     ...
 * }
 *
 * Using templates:
 *
 * - The '__class' property is metadata describing the Parse class for this
 *   object.
 * - Strings, booleans, numbers, & arrays are used "as expected" when searching
 *   for and creating objects.
 * - Objects that have '__type: "ParseFile"' are special:
 *   - These are not included in searches due to Parse limitations.
 *   - On creation, we look for the source file in a path generated by taking
 *     the aboslute path to the migration file, and replacing the ".js"
 *     extension with "__files". For the above example, that path might look
 *     like:
 *     /home/alexi/parse-migrations/20140918-migration_files/something.png
 *  - Objects that have '__search: "ParseClass"' are special:
 *    - On search, we create sub-queries that must be matched.
 *    - On create, we search for and reference an object that matches.
 *      At present, if more than 1 object is in the search results, this will
 *      throw an error.
 */
 
var _ = require('underscore');
var assert = require('assert');
var path = require('path');
var fs = require('fs');

// Keep JSHint cool because it thinks we're redefining Parse
/*jshint -W079 */
var Parse;
var MIGRATION_FILE_PATH;

/**
 * Set up the helper module for this migration.
 * 
 * @param {object} A properly initialized handle to the Parse JS SDK
 * @param {string} The full path to the migration script being run
 */
exports.init = function(ParseObject, migrationFilePath) {
    // JSHint freaks out because it thinks Parse is a read-only object
    /*jshint -W020 */
    Parse = ParseObject;
    if (migrationFilePath) {
        MIGRATION_FILE_PATH = migrationFilePath;
    }
};

/**
 * Internal function.
 * Creates a deep copy of an object, omitting properties that are functions.
 *
 * @param {object} object
 * @returns {object}
 */
function deepCopy(object) {
    return JSON.parse(JSON.stringify(object));
}


/**
 * Internal function.
 * Creates a Parse.File object from a template specification. The file contents
 * are found by the following rules:
 *   - Take MIGRATION_FILE_PATH (which is the full path to the migration file)
 *   - Replace the trailing '.js' extension with '_files'
 *   - Append the OS's path separator
 *   - The file name is used from the parameter: fileTemplate.filename
 *
 * @param {object} fileTemplate
 * @returns {Parse.File|null}
 * @throws 'Could not find source file'
 */
function createParseFile(fileTemplate) {
    var filePath = MIGRATION_FILE_PATH.substr(0, MIGRATION_FILE_PATH.lastIndexOf('.')) +
                   '_files' +
                   path.sep +
                   fileTemplate.filename;
    var parseFile;

    if (fs.existsSync(filePath)) {
        // Stolen shamelessly from
        // https://www.parse.com/questions/how-to-upload-parsefile-from-nodejs
        var fileData = fs.readFileSync(filePath);
        fileData = Array.prototype.slice.call(new Buffer(fileData), 0);
        parseFile = new Parse.File(fileTemplate.filename,
                                   fileData);
    } else {
        throw new Error('Could not find file for upload: ' + filePath);
    }
    
    return parseFile;
}

/**
 * Internal function.
 * Takes a search template object (see `property6` in the example at the top
 * of this file) and makes a copy of it as a regular template object. This is
 * necessary when you want to create a query from a search template object.
 *
 * @param {object} searchTemplate
 * @returns {object}
 */
function searchTemplateToRegularTemplate(searchTemplate) {
    var objectTemplate = deepCopy(searchTemplate);

    objectTemplate.__class = objectTemplate.__search;
    delete objectTemplate.__search;

    return objectTemplate;
}

/**
 * Creates a Parse.Query object that matches the properties listed in the
 * given objectTemplate object.
 *
 * @param   {object} objectTemplate
 * @returns {Parse.Query}
 */
function createQueryForObjectTemplate(objectTemplate) {
    if (objectTemplate.hasOwnProperty('__search')) {
        // We've been given a search template (see 'property6' in the example
        // at the top of the file.) Convert it to a regular template.
        objectTemplate = searchTemplateToRegularTemplate(objectTemplate);
    }

    assert(_.isString(objectTemplate.__class),
           'objectTemplate requires __class property');

    var className = objectTemplate.__class;
    var query = new Parse.Query(className);

    for (var key in objectTemplate) {
        if (key === '__class') {
            continue;
        }

        if (_.isString(objectTemplate[key]) ||
            (typeof objectTemplate[key] === 'boolean') ||
            (typeof objectTemplate[key] === 'number'))
        {
            query.equalTo(key, objectTemplate[key]);
        } else if (_.isArray(objectTemplate[key])) {
            query.containsAll(key, objectTemplate[key]);
        } else {
            if (objectTemplate[key].hasOwnProperty('__type')) {
                // Skip query parameters for properties that are pointers to
                // special types
                continue;
            } else if (objectTemplate[key].hasOwnProperty('__search')) {
                var subQuery = createQueryForObjectTemplate(objectTemplate[key]);
                query.matchesQuery(key, subQuery);
            } else {
                // If the object template property is an arbitrary object,
                // we're just going to skip it. Parse does not support
                // querying for JSON objects.
                continue;
            }
        }
    }

    return query;
}

/**
 * Search for a Parse object that has the same attributes as the objectTemplate
 * that was supplied.
 *
 * @param   {object} objectTemplate
 * @returns {Parse.Promise}
 */
function searchForObjectTemplate(objectTemplate) {
    var query = createQueryForObjectTemplate(objectTemplate);

    return query.find();
}
exports.searchForObjectTemplate = searchForObjectTemplate;

/**
 * Create a new Parse object from an object template.
 *
 * @param   {object} objectTemplate
 * @returns {Parse.Promise}
 */
function createObjectFromTemplate(objectTemplate) {
    assert(objectTemplate.__class, 'objectTemplate requires __class property');

    var Class = Parse.Object.extend(objectTemplate.__class);
    var object = new Class();
    var promises = [];

    // Loop through the keys of the objectTemplate taking the appropriate
    // actions. Most of the time that just means setting a value on the Parse
    // object, but there are special cases.
    for (var key in objectTemplate) {
        var objectProperty = objectTemplate[key];

        if (objectProperty.hasOwnProperty('__type')) {
            switch (objectProperty.__type) {
                case 'ParseFile':
                    object.set(key, createParseFile(objectProperty));
                    break;
                default:
                    console.warn('unsupported object __type: ' +
                                 JSON.stringify(objectProperty));
                    break;
            }
        } else if (objectProperty.hasOwnProperty('__search')) {
            var searchPromise = searchForObjectTemplate(objectProperty).then(
                /*jshint -W083 */
                function(searchResults) {
                    if (searchResults.length === 1) {
                        object.set(key, searchResults[0]);
                    } else {
                        var errorMessage = '!!! error while trying to find object ' +
                            'reference: no single match found for template ' +
                            '(results: ' +
                            JSON.stringify(searchResults) +
                            ')';

                        return Parse.Promise.error(new Error(errorMessage));
                    }
                }
            );

            promises.push(searchPromise);

        } else if (key !== '__class') {
            object.set(key, objectProperty);
        }
    }

    return Parse.Promise.when(promises).then(function() {
        object.save();
    });
}
exports.createObjectFromTemplate = createObjectFromTemplate;

/**
 * Iterates through an array of object templates, looks to see if an object
 * exists in Parse that resembles the template, and if not, creates a new
 * object for that template.
 *
 * @param   {array}  objectTemplates
 * @returns {Parse.Promise}
 */
function createUniqueObjectsFromTemplates(objectTemplates) {
    var objectTemplate = objectTemplates.pop();
    return searchForObjectTemplate(objectTemplate).then(
        function(searchResult) {
            if (searchResult.length === 0) {
                console.log('creating object');
                return createObjectFromTemplate(objectTemplate);
            } else if (searchResult.length === 1) {
                console.log('object exists, skipping creation');
                return Parse.Promise.as('Found an object matching this one... skipping creation.');
            } else {
                console.warn('found multiple objects matching template: ' +
                             JSON.stringify(objectTemplate));
                return Parse.Promise.as('Found an object matching this one... skipping creation.');
            }
        }
    ).then(
        function() {
            if (objectTemplates.length > 0) {
                // Recurse back into this function with a slightly smaller
                // objectTemplates array (the first item has been popped off the
                // array.)
                return createUniqueObjectsFromTemplates(objectTemplates);
            } else {
                return Parse.Promise.as(true);
            }
        }
    );
}
exports.createUniqueObjectsFromTemplates = createUniqueObjectsFromTemplates;
