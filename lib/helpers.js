/* global exports */
'use strict';

/**
 * This module contains helper functions for migration scripts. The bulk of
 * its functionality hinges on "object templates." These are JS objects that
 * can be used to model Parse objects that you might want to either search for
 * or create.
 *
 * A template object looks like this:
 * {
 *     __class: 'ParseClassName',
 *     property1: 'Some Parse property',
 *     property2: false,
 *     property3: 42,
 *     property4: ['abc', '123'],
 *     property5: {
 *         __type: 'ParseFile',
 *         filename: 'somefile.png' },
 *     ...
 * }
 *
 * Things to note:
 * - The '__class' property is metadata describing the Parse class for this
 *   object.
 * - Strings, booleans, numbers, & arrays are used "as expected" when searching
 *   for and creating objects.
 * - Objects that have '__type: "ParseFile"' are special:
 *   - These are not included in searches due to Parse limitations.
 *   - On creation, we look for the source file in a path generated by taking
 *     the aboslute path to the migration file, and replacing the ".js"
 *     extension with "__files". For the above example, that path might look
 *     like:
 *     /home/alexi/parse-migrations/20140918-migration_files/something.png
 * - Object that have '__type: "ParseObject"' are special:
 *   - COMING SOON!
 */
 
var _ = require('underscore');
var assert = require('assert');
var path = require('path');
var fs = require('fs');

// Keep JSHint cool because it thinks we're redefining Parse
/*jshint -W079 */
var Parse;
var MIGRATION_FILE_PATH;

/**
 * Set up the helper module for this migration.
 * 
 * @param {ParseObject} A properly initialized handle to the Parse JS SDK
 * @param {migrationFilePath} The full path to the migration script being run
 */
exports.init = function(ParseObject, migrationFilePath) {
    // JSHint freaks out because it thinks Parse is a read-only object
    /*jshint -W020 */
    Parse = ParseObject;
    if (migrationFilePath) {
        MIGRATION_FILE_PATH = migrationFilePath;
    }
};

/**
 * Search for a Parse object that has the same attributes as the objectTemplate
 * that was supplied.
 *
 * @param   {Object} objectTemplate
 * @returns {Parse.Promise}
 */
function searchForObjectTemplate(objectTemplate) {
    assert(_.isString(objectTemplate.__class),
           'objectTemplate requires __class property');

    var className = objectTemplate.__class;
    var query = new Parse.Query(className);

    for (var key in objectTemplate) {
        if (key === '__class') {
            continue;
        }

        if (_.isString(objectTemplate[key]) ||
            (typeof objectTemplate[key] === 'boolean') ||
            (typeof objectTemplate[key] === 'number'))
        {
            query.equalTo(key, objectTemplate[key]);
        } else if (_.isArray(objectTemplate[key])) {
            query.containsAll(key, objectTemplate[key]);
        } else {
            if (objectTemplate[key].hasOwnProperty('__type')) {
                // Skip properties that are pointers to other Parse objects
                // TODO: support matching these? Or just make it a shallow
                //       search?
                switch (objectTemplate[key].__type) {
                    case 'ParseFile':
                        break;
                    case 'ParseObject':
                        break;
                    default:
                        console.warn('unsupported object: ' +
                                     JSON.stringify(objectTemplate[key]));
                        break;
                }
                continue;
            }
            return Parse.Promise.error('Unsupported template data type');
        }
    }

    return query.find();
}
exports.searchForObjectTemplate = searchForObjectTemplate;

/**
 * Create a new Parse object from an object template.
 *
 * @param   {Object} objectTemplate
 * @returns {Parse.Promise}
 */
function createObjectFromTemplate(objectTemplate) {
    var Class = Parse.Object.extend(objectTemplate.__class);
    var object = new Class();

    for (var key in objectTemplate) {
        if (objectTemplate[key].hasOwnProperty('__type')) {
            switch (objectTemplate[key].__type) {
                case 'ParseFile':
                    var filePath = MIGRATION_FILE_PATH.substr(0, MIGRATION_FILE_PATH.lastIndexOf('.')) +
                                   '_files' +
                                   path.sep +
                                   objectTemplate[key].filename;
                    console.log('attempting to upload file: ' + filePath);
                    if (fs.existsSync(filePath)) {
                        // Stolen shamelessly from
                        // https://www.parse.com/questions/how-to-upload-parsefile-from-nodejs
                        var fileData = fs.readFileSync(filePath);
                        fileData = Array.prototype.slice.call(new Buffer(fileData), 0);
                        var parseFile = new Parse.File(objectTemplate[key].filename,
                                                       fileData);
                        object.set(key, parseFile);
                    } else {
                        console.error('!!! could not find file for upload: ' + filePath);
                        return Parse.Promise.error('could not find file for upload');
                    }
                    break;
                case 'ParseObject':
                    // TODO: handle creating object linkages
                    break;
                default:
                    console.warn('unsupported object: ' +
                                 JSON.stringify(objectTemplate[key]));
                    break;
            }
        } else if (key !== '__class') {
            object.set(key, objectTemplate[key]);
        }
    }

    return object.save();
}
exports.createObjectFromTemplate = createObjectFromTemplate;

/**
 * Iterates through an array of object templates, looks to see if an object
 * exists in Parse that resembles the template, and if not, creates a new
 * object for that template.
 *
 * @param  {Array}  objectTemplates
 * @returns {Parse.Promise}
 */
function createUniqueObjectsFromTemplates(objectTemplates, migrationFilePath) {
    if (migrationFilePath) {
        MIGRATION_FILE_PATH = migrationFilePath;
    }

    var objectTemplate = objectTemplates.pop();
    return searchForObjectTemplate(objectTemplate).then(
        function(searchResult) {
            if (searchResult.length === 0) {
                console.log('creating object');
                return createObjectFromTemplate(objectTemplate);
            } else if (searchResult.length === 1) {
                console.log('object exists, skipping creation');
                return Parse.Promise.as('Found an object matching this one... skipping creation.');
            } else {
                console.warn('found multiple objects matching template: ' +
                             JSON.stringify(objectTemplate));
                return Parse.Promise.as('Found an object matching this one... skipping creation.');
            }
        }
    ).then(
        function() {
            if (objectTemplates.length > 0) {
                // Recurse back into this function with a slightly smaller
                // objectTemplates array (the first item has been popped off the
                // array.)
                return createUniqueObjectsFromTemplates(objectTemplates);
            } else {
                return Parse.Promise.as(true);
            }
        }
    );
}
exports.createUniqueObjectsFromTemplates = createUniqueObjectsFromTemplates;
